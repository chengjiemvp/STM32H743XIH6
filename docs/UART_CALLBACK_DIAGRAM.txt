UART接收回调函数调用顺序 - 快速参考图
===========================================

当UART接收到一个字节时的完整调用流程：


  ┌─────────────────────────────────────────────────────────────┐
  │                    UART数据接收流程                          │
  └─────────────────────────────────────────────────────────────┘

     [硬件层]  USART1硬件接收完成 → 触发中断
                        ↓
     ┌──────────────────────────────────────────────┐
     │ Layer 1: 硬件中断                            │
     │ - NVIC触发USART1中断                         │
     │ - 中断向量表跳转                             │
     └──────────────────────────────────────────────┘
                        ↓
     ┌──────────────────────────────────────────────┐
     │ Layer 2: 中断服务程序 (ISR)                 │
     │ 函数: USART1_IRQHandler()                   │
     │ 文件: Core/Src/stm32h7xx_it.c:222          │
     │ 作用: 中断向量表入口                         │
     └──────────────────────────────────────────────┘
                        ↓
     ┌──────────────────────────────────────────────┐
     │ Layer 3: HAL库中断处理                       │
     │ 函数: HAL_UART_IRQHandler(&huart1)          │
     │ 文件: stm32h7xx_hal_uart.c (HAL库)         │
     │ 作用: 读取数据、清除标志、调用回调           │
     └──────────────────────────────────────────────┘
                        ↓
     ┌──────────────────────────────────────────────┐
     │ Layer 4: C/C++桥接层                        │
     │ 函数: HAL_UART_RxCpltCallback()             │
     │ 文件: Core/Src/app_callbacks.cpp:29        │
     │ 作用: extern "C" 桥接，调用C++对象          │
     └──────────────────────────────────────────────┘
                        ↓
     ┌──────────────────────────────────────────────┐
     │ Layer 5: C++类中断处理                       │
     │ 函数: Uart::get_instance().isr_handler()   │
     │ 文件: Core/Src/Uart.cpp:50                 │
     │ 作用: 数据处理核心                           │
     └──────────────────────────────────────────────┘
              ↓                    ↓
     ┌────────────────┐   ┌─────────────────────┐
     │ Layer 6:       │   │ Layer 7:            │
     │ 环形缓冲区     │   │ 用户回调指针        │
     │ rx_buffer_     │   │ rx_callback_()      │
     │ .push()        │   │                     │
     └────────────────┘   └─────────────────────┘
              ↓                    ↓
     主循环可以轮询读取    ┌─────────────────────┐
     available() / read()  │ Layer 8:            │
                           │ 用户回调函数        │
                           │ uart_rx_callback()  │
                           └─────────────────────┘
                                    ↓
                           ┌─────────────────────┐
                           │ Layer 9:            │
                           │ 实际处理            │
                           │ printf("%c", byte)  │
                           └─────────────────────┘


═══════════════════════════════════════════════════════════════

  关键初始化顺序 (Core/Src/main.cpp)
  
  1. MX_USART1_UART_Init()         // HAL硬件初始化
  2. Uart::init(&huart1)            // 创建单例对象
  3. set_rx_callback(uart_rx_callback)  // 注册回调
  4. Uart::begin()                  // 启动中断接收 ← 重要！
  
  ⚠️ 警告: 必须按顺序执行，否则会崩溃！

═══════════════════════════════════════════════════════════════

  数据访问的两种方式
  
  方式1 - 实时回调 (立即处理):
  ┌─────────────────────────────────────────┐
  │ UART接收 → isr_handler()                │
  │          → rx_callback_()               │
  │          → uart_rx_callback()           │
  │          → printf() 立即打印             │
  └─────────────────────────────────────────┘
  优点: 延迟最小
  缺点: 在ISR上下文，必须快速返回
  
  方式2 - 轮询读取 (延迟处理):
  ┌─────────────────────────────────────────┐
  │ UART接收 → isr_handler()                │
  │          → rx_buffer_.push()            │
  │ 主循环   → available() 检查             │
  │          → read() 读取                  │
  │          → 慢慢处理                      │
  └─────────────────────────────────────────┘
  优点: 可以慢慢处理
  缺点: 需要定期轮询，缓冲区满时丢数据

═══════════════════════════════════════════════════════════════

  中断安全设计
  
  ✓ volatile 变量 (RingBuffer的head/tail)
  ✓ 初始化检查 (Uart::is_initialized())
  ✓ placement new (避免SDRAM分配)
  ✓ 单生产者单消费者 (无锁设计)
  
═══════════════════════════════════════════════════════════════

更多详细信息请参阅: docs/UART_CALLBACK_FLOW.md
